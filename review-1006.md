# Magnite x Cursor/GPT-5 — Meeting Notes and Review (2025-10-06)

## Executive Summary
- **Focus of the session**: lessons on prompt vs context engineering, RIPER‑5 modes, Cursor vs Codex roles, and practical workflow patterns.
- **Primary outcomes**: a shared vocabulary for working with agents, best‑practice prompting patterns, and a repeatable setup for projects (rules, plans, logs, envs).
- **Output to produce next**: an HTML deck summarizing these lessons (using `magnite-style-guide.md`) plus a small internal playbook of example prompts.
- **Example (secondary)**: we briefly wired a basic Gong MCP to illustrate the principles.

## Project File Review
- `index.html` — Initial PowerPoint-style deck created with Claude Code using the `magnite-style-guide.md`. Later restyled as an example using `obz-style-guide.md`.
- `index2.html` — Alternate deck generated by Codex; serves as a contrast example.
- `notes-1006-expanded.md` — Source content used to drive both decks.
- `meeting-1006.md` — Transcript from today’s session (teaching + build segment).
- `magnite-style-guide.md` — Useful starting point for fast, branded UI (purple gradient look); adapt as needed.
- `obz-style-guide.md` — OnBreeze house style used by Mike; alternative to Magnite’s style.
- `progress.md` — Emoji-prefixed log of “vagentic” actions taken during the session.
- `README-setup.md` — Setup aid for agents (Cursor/Claude/Codex) to ensure local Python/Node prerequisites.
- `RIPER-5.md` — Mental framework; use modes to guide agents (no longer required as strict rules, still helpful).

## Core Lessons & Takeaways

### 1) Prompt Engineering vs Context Engineering
- **Prompt engineering**: how you ask (issue → rules → analysis → conclusion). Lead with objectives and rules; close with a crisp checklist.
- **Context engineering**: how much the model can attend to. Keep chats scoped; prefer new chats for new tasks; avoid dragging long histories across tasks.
- Keep prompts compact but explicit (rules > personas); favor positive/negative constraints (what to do / what not to do).
- Expect context growth to be non‑linear; use plan modes or break work into phases to reduce token pressure.

Practical example (from session):
- We split "teach concepts" (short chat, links + rules) from "build MCP" (separate chat with only the relevant files + env), which reduced confusion and produced cleaner edits.

### 2) RIPER‑5 Modes (mental model)
- **Research**: gather code/docs; do not change code.
- **Innovate**: brainstorm options and tradeoffs.
- **Plan**: produce a concrete, checkable action plan.
- **Execute**: apply edits per plan; keep logs short and emoji‑prefixed.
- **Review**: sanity checks, diffs, and acceptance criteria before moving on.

Checklist we used live:
- Declare mode at turn start, forbid code edits in Research/Innovate, move to Plan only when options are compared, and return to Plan if Execute reveals a gap.

### 3) Cursor Chat vs Codex (roles)
- **Cursor Chat**: tight feedback loop; best for research, quick fixes, debugging, and incremental edits.
- **Codex/Cloud Code**: long‑running, multi‑file changes; provide rules (`agents.md`) and planning docs; optionally stage in plan mode before executing.

Decision guideline:
- If it needs 10+ minutes or touches many files, codify rules + plan and use Codex; otherwise prefer Cursor Chat for speed and control.

### 4) Project Scaffolding Patterns
- `agents.md` (rules), `progress.md` (emoji logs), lightweight plan docs, and a clear folder layout.
- Secrets in `.env` and referenced via config (no inline secrets). Keep MCP configs local to projects for scoped context.
- Favor few, general tools; compose them rather than adding narrow tools that bloat surface area.

What we set up today:
- `progress.md` for emoji logs, local MCP config, and a habit of appending resources/notes at the top (newest first).

### 5) Communication & UI Patterns
- Follow `magnite-style-guide.md` for decks/UX: high‑contrast gradients, clear hierarchy, subtle motion.
- Use “slide‑as‑card” patterns with phase badges and concise callouts for tips/links.

When building decks:
- Start with goals → lessons → checklists → example appendix; keep each slide focused on one idea.

## How‑Tos / Tips & Tricks
- Use slash/terminal context checks to monitor token usage; split tasks when context > ~50%.
- Begin prompts with goals + rules; end with a bullet checklist of outputs/constraints.
- Separate research/plan/execute into distinct turns (or chats) to avoid chaotic edits.
- Keep logs readable and scannable: emoji prefix, one line per event.
- For UI deliverables, pair content files (notes) with the style guide; generate decks from structured outlines.

Prompt patterns we used (copy/paste):

```text
Goal: [what you need]
Rules: [link or file refs], keep context ≤ X, do not edit code in Research.
Deliver: [bulleted outputs/checklist]
Mode: [Research|Plan|Execute]
```

```text
We are in PLAN mode.
- Read: agents.md, notes-1006-expanded.md (only the sections on context engineering).
- Produce: a numbered plan with file paths and acceptance checks.
- Do not write code yet.
```

```text
We are in EXECUTE mode.
- Apply only steps 1–3 from the approved plan.
- After each file edit, add a short emoji log to progress.md.
- If anything requires deviation, STOP and return to PLAN.
```

Context compaction prompt (before long turns):

```text
Summarize prior chat into <200 lines focusing on decisions, open questions, and file touchpoints.
Remove digressions. Output: Decisions, Open Questions, Files.
```

## Risks & Mitigations
- **Empty transcripts**: build summary-first flow (outlines/briefs) and mark derived vs primary sources.
- **Rate limits**: throttle and page; queue large backfills; run nightly + webhook/polling for incrementals.
- **Ambiguity in terms**: use glossary and product dictionary; add disambiguation examples in prompts.

Additional risks from session:
- **Overgrown context**: split chats by task; re‑seed with only the files needed.
- **Runaway edits**: enforce mode discipline; require plan checklists before Execute in large changes.
- **Secrets exposure**: verify `.gitignore` for `.env`; avoid pasting secrets into chats.

## Next Steps (for the Magnite team)
1) Pull the repo and wire Gong MCP
   - Clone the GitHub repo fresh in Cursor.
   - Set `GONG_ACCESS_KEY` and `GONG_ACCESS_SECRET` in `.env` (do not commit).
   - Ensure `.cursor/mcp.json` includes the Gong server; reload MCPs.

2) Smoke‑test the MCP in Cursor
   - Ask the agent to list Gong tools and then list calls for the last 7 days (cap at 50–100).
   - Retrieve one call’s brief/outline; save assets under `gong/transcripts/` (or `gong/transcripts/<id>.*`).

3) Create an upgrade plan doc
   - Inputs: `gong/docs/discovery-call-1006.md`, this review, and your tenant needs.
   - Mode sequence in Cursor: Research → Brainstorm → Plan.
   - Deliverables in the plan:
     - Tools to add/adjust
     - Data shapes, normalization, and flags (`includeEntities`, `includeTrackers`, summaries-first fallback).
     - Logging (emoji prefixes), error envelopes, rate‑limit strategy.
     - Tests and acceptance criteria for each tool.

4) Execute with Codex
   - Run Codex from the repo root; feed the plan and relevant files as rules.
   - Implement exactly as planned; log changes in `progress.md` (emoji‑prefixed).
   - Open a PR or save a change summary in the plan doc.


## HTML Deck Outline (for `index2.html`-style deck)
- Slide 1 — Title & Goals: Why this matters; how to use these patterns tomorrow.
- Slide 2 — Prompt vs Context Engineering: definitions, rules, token discipline.
- Slide 3 — RIPER‑5 Modes: when/why; examples of each mode.
- Slide 4 — Cursor vs Codex: roles, when to switch, plan mode.
- Slide 5 — Project Scaffolding: agents, plans, logs, envs; structure that scales.
- Slide 6 — Tips & Tricks: prompting checklists, logging format, split chats.
- Slide 7 — Resources: files to read next; where to find examples.
- Slide 8 — Example Appendix: brief on the Gong MCP we wired and what to do next if adopting it.

Slide content hints (to keep build fast):
- Use phase badges for modes (Research/Plan/Execute/Review).
- Convert prompt patterns above into code blocks on slides.
- Place link chips to repo files (`RIPER-5.md`, `AGENTS.md`, `magnite-style-guide.md`).

## Appendix — Example: Gong MCP (brief)
- We connected a basic MCP to list calls; many calls lacked transcripts, so we prefer summary/outline fields.
- If pursuing this path, add compact tools (`get_call_brief`, `get_call_outline`) and seed a lightweight taxonomy.
- Treat this as a worked example of the lessons above (context discipline, plan/execute, minimal tool surface).

Tiny checklist if you continue the Gong path:
- Verify env: `GONG_ACCESS_KEY`/`GONG_ACCESS_SECRET`.
- List calls with pagination + backoff; persist minimal call index.
- Add brief/outline tools; store alongside transcripts.
- Draft persona templates (Exec/PM) and test on ~10 calls.

## Resources
- Repo files: `RIPER-5.md`, `AGENTS.md`, `RULES.MD`, `magnite-style-guide.md`, `index.html`, `index2.html`.
- MCP docs/examples: `gong/plan-mcp-v2.md`, `gong/plan-gong-upgrade.md`, `gong/docs/mcp_resources.md`.
- MCP discovery: `cursor.directory`.

Link index used during the talk:
- Prompt engineering overview — `notes-1006-expanded.md` (Slide 1 section)
- Context engineering blog — `notes-1006-expanded.md` (Slide 2 link)
- Deep Agents reference — `notes-1006-expanded.md` (Slide 4 link)


